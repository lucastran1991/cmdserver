import uuid
from typing import Optional, Dict
import os
import json
from datetime import datetime, timedelta

from fastapi import Depends, Request
from fastapi_users import BaseUserManager, FastAPIUsers, UUIDIDMixin, models
from fastapi_users.authentication import (
    AuthenticationBackend,
    BearerTransport,
    JWTStrategy,
)
from fastapi_users.db import SQLAlchemyUserDatabase

from app.db import User, get_user_db

config_path = os.path.join(os.path.dirname(__file__), "../../config.json")
with open(config_path) as config_file:
    config = json.load(config_file)

SECRET = config["backend"]["secret_key"]

# Add token cache to store active tokens
active_tokens: Dict[str, dict] = {}


class UserManager(UUIDIDMixin, BaseUserManager[User, uuid.UUID]):
    reset_password_token_secret = SECRET
    verification_token_secret = SECRET

    async def on_after_login(
        self, user: User, request: Optional[Request] = None, response=None
    ):
        # Check if user already has a valid token
        user_id = str(user.id)
        if user_id in active_tokens:
            token_data = active_tokens[user_id]
            if datetime.now() < token_data["expires_at"]:
                # Return existing token instead of generating new one
                return token_data["token"]

        # If no valid token exists, the new token will be generated by the auth backend
        print(f"User {user.id} logged in.")

    async def on_after_register(self, user: User, request: Optional[Request] = None):
        print(f"User {user.id} has registered.")

    async def on_after_forgot_password(
        self, user: User, token: str, request: Optional[Request] = None
    ):
        print(f"User {user.id} has forgot their password. Reset token: {token}")

    async def on_after_request_verify(
        self, user: User, token: str, request: Optional[Request] = None
    ):
        print(f"Verification requested for user {user.id}. Verification token: {token}")


async def get_user_manager(user_db: SQLAlchemyUserDatabase = Depends(get_user_db)):
    yield UserManager(user_db)


# Custom JWT Strategy that checks for existing tokens
class CustomJWTStrategy(JWTStrategy[models.UP, models.ID]):
    async def write_token(self, user: models.UP) -> str:
        user_id = str(user.id)

        # Check if user already has a valid token
        if user_id in active_tokens:
            token_data = active_tokens[user_id]
            if datetime.now() < token_data["expires_at"]:
                return token_data["token"]

        # Generate new token
        token = await super().write_token(user)

        # Store token in cache
        active_tokens[user_id] = {
            "token": token,
            "expires_at": datetime.now() + timedelta(seconds=self.lifetime_seconds),
        }

        return token


bearer_transport = BearerTransport(tokenUrl="auth/jwt/login")


def get_jwt_strategy() -> CustomJWTStrategy:
    return CustomJWTStrategy(secret=SECRET, lifetime_seconds=3600)


auth_backend = AuthenticationBackend(
    name="jwt",
    transport=bearer_transport,
    get_strategy=get_jwt_strategy,
)

fastapi_users = FastAPIUsers[User, uuid.UUID](get_user_manager, [auth_backend])

current_active_user = fastapi_users.current_user(active=True)